import{_ as e,r as o,o as p,c,b as n,d as s,a as t,e as i}from"./app-vMCaIZpZ.js";const l="/assets/Pasted_image_20240424173447-59WvTvCn.png",r="/assets/Pasted_image_20240423104014-R96HyVwW.png",u="/assets/Pasted_image_20240423103915-Z4kqGb7m.png",d="/assets/Pasted_image_20240424162844-RmXUoG_V.png",k="/assets/Pasted_image_20240424162903-CKrggCPH.png",m="/assets/Pasted_image_20240424163026-VlONbhJR.png",g="/assets/Pasted_image_20240424161213-z51XEuAa.png",v="/assets/Pasted_image_20240424162115-wupmVUNA.png",_="/assets/Pasted_image_20240424163138-3fYcj8Kl.png",h="/assets/Pasted_image_20240424163157-UeWSpwVG.png",b="/assets/Pasted_image_20240424172312-6m4Vcy5V.png",f="/assets/Pasted_image_20240424163357-SuU6-BMa.png",w="/assets/Pasted_image_20240424165010-hAPIG0If.png",y="/assets/Pasted_image_20240424170345-sBeDmM_5.png",x="/assets/Pasted_image_20240424165156-K4zMTmBv.png",P="/assets/Pasted_image_20240424171344-x9pfAuWU.png",T="/assets/Pasted_image_20240424171549-attpTjhO.png",j={},q=n("h1",{id:"字节码中的-utf8-overlong-encoding-初探",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#字节码中的-utf8-overlong-encoding-初探","aria-hidden":"true"},"#"),s(" 字节码中的 UTF8 Overlong Encoding 初探")],-1),E={href:"https://github.com/Ar3h/utf8-overlong-agent",target:"_blank",rel:"noopener noreferrer"},z=i('<p>CC5链生成的流量混淆非常完美 <img src="'+l+'" alt=""></p><p>但是发现CC4中因为使用到了字节码，byte字节流里是不会UTF8编码的，所以无法使用overlong <img src="'+r+'" alt=""></p><p>序列化时并没有调用writeUTF8Body方法 <img src="'+u+`" alt=""> 这样还是有一些痛点的，反序列化流量中仍然能检测一些关键词</p><p>于是思路看向了字节码自身的混淆，看字节码的解析过程中是否也存在overlong呢？</p><h2 id="字节码下的overlong" tabindex="-1"><a class="header-anchor" href="#字节码下的overlong" aria-hidden="true">#</a> 字节码下的overlong</h2><p>写一个测试的字节码文件</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>  
  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBytecode</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">try</span> <span class="token punctuation">{</span>  
            <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&quot;calc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译成字节码</p><p>我们直接修改最明显的方法名，变成overlong utf8 encoding</p><p>把R字符 overlong 一下，并且更改常量对应的长度 <img src="`+d+'" alt=""></p><p>运行发现报错，这个错误是在类加载的过程中报错 <img src="'+k+'" alt=""></p><p>根据字节码格式，常量池有一个tag为1的标识：<code>CONSTANT_Utf8_info</code></p><blockquote><p>https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.7</p></blockquote><p><img src="'+m+'" alt=""></p><p>找到JVM对应的处理逻辑，hotspot/src/share/vm/classfile/classFileParser.cpp下 <img src="'+g+'" alt=""></p><p>verify_legal_utf8 函数中会校验utf8字符串是否合法，但是如果字节码主版本 &lt;= 47会跳过校验，这样可能会存在 overlong 问题 <img src="'+v+'" alt=""></p><p>我们尝试一下，将字节码版本改成47后 <img src="'+_+'" alt=""></p><p>运行后发现是另一个报错，提示找不到类定义，说明类加载已经完成了，但是运行过程中因为编码问题找不到类 <img src="'+h+'" alt=""></p><p>我们换其他，尝试overlong字符串，也就是calc的c字符，生成十六进制为c1a3 <img src="'+b+'" alt=""></p><p>发现可以正常运行 <img src="'+f+`" alt=""> 说明字符串可以实现overlong</p><p>我们还可以测试自定义的方法名看能否utf8 overlong encoding</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBytecode</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Ar3h&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+w+`" alt=""> 发现没有问题</p><p>同样的，字段名也可以overlong</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBytecode</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> testField <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span>  
  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testField<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Ar3h&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+y+'" alt=""></p><p>这种对于流量层过waf有一点点效果吧，不过对于fernflower没有混淆效果，反编译后还是正常显示： <img src="'+x+'" alt=""></p><h2 id="反序列化中的字节码overlong初探" tabindex="-1"><a class="header-anchor" href="#反序列化中的字节码overlong初探" aria-hidden="true">#</a> 反序列化中的字节码overlong初探</h2><p>将以上姿势应用到反序列化中，手动将字节码版本、字符串更改后，另外还需要更改前面标识字节流的长度，否则会报错： <img src="'+P+'" alt=""></p><p>之后就可以正常执行反序列化 <img src="'+T+'" alt=""></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>目前通过修改字节码版本标识，绕过了类加载时的 utf8 overlong encoding检测，实现了在常量池中的字符串、方法名、字段名进行overlong encoding。</p><p>若将调用已有的类名方法名字段名的常量池中的对象字符串进行overlong，会在运行过程中提示类似<code>java.lang.NoClassDefFoundError</code>的错误，应该是JVM没有匹配成功。</p><p>目前感觉实战价值不是很高，稍显鸡肋，因为最关键的<code>com/sun/org/apache/xalan/internal/xsltc/DOM</code>、<code>com/sun/org/apache/xml/internal/serializer/SerializationHandler</code>等常用gadget类暂时还未能做到隐藏。</p><p>不过可以尝试将代码中的字符串进行overlong，把自己的字节码主要逻辑封装到编码后的base64字符串中，外层使用ClassLoader进行解码和加载类，绕过一些关键词检测。</p><p>本文当作抛砖引玉，希望大佬们能研究出更多的利用面。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',37),N={href:"https://www.leavesongs.com/PENETRATION/utf-8-overlong-encoding.html",target:"_blank",rel:"noopener noreferrer"},V={href:"https://github.com/Whoopsunix/utf-8-overlong-encoding",target:"_blank",rel:"noopener noreferrer"},S={href:"https://t.zsxq.com/ToFaL",target:"_blank",rel:"noopener noreferrer"},A={href:"https://t.zsxq.com/Yg2cc",target:"_blank",rel:"noopener noreferrer"},C={href:"https://xz.aliyun.com/t/14300",target:"_blank",rel:"noopener noreferrer"};function F(O,U){const a=o("ExternalLinkIcon");return p(),c("div",null,[q,n("p",null,[s("学习反序列化 utf8 overlong encoding 后，通过 agent hook函数实现了utf8 overlong encdoing 的生成："),n("a",E,[s("https://github.com/Ar3h/utf8-overlong-agent"),t(a)])]),z,n("p",null,[n("a",N,[s("https://www.leavesongs.com/PENETRATION/utf-8-overlong-encoding.html"),t(a)])]),n("p",null,[n("a",V,[s("https://github.com/Whoopsunix/utf-8-overlong-encoding"),t(a)])]),n("p",null,[n("a",S,[s("https://t.zsxq.com/ToFaL"),t(a)])]),n("p",null,[n("a",A,[s("https://t.zsxq.com/Yg2cc"),t(a)])]),n("p",null,[n("a",C,[s("https://xz.aliyun.com/t/14300"),t(a)])])])}const R=e(j,[["render",F],["__file","chutanzijiemazhongdeUTF8-Overlong-Encoding.html.vue"]]);export{R as default};
